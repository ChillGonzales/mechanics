#pragma once
#include <iostream>
#include "..\mechanics\model.h"
#include <reactphysics3d/reactphysics3d.h>
#include "scene_manager.h"

using namespace std;
using namespace reactphysics3d;

struct SceneLoader
{
	bool writeSceneToDisk(string pathWithNameAndExt, string name, struct RenderingState* renders, struct PhysicsState* phy_entities, PhysicsWorld* world, unsigned int entity_count)
	{
		std::ofstream sceneFile;
		sceneFile.exceptions(std::ofstream::failbit | std::ofstream::badbit);
		try
		{
			// open file
			sceneFile.open(pathWithNameAndExt);
			if (!sceneFile.is_open())
			{
				cout << "Could not open scene file at location: '" << pathWithNameAndExt << "'.";
				return false;
			}

			sceneFile << "***AUTOGENERATED FILE CREATED BY scene_loader.h***\n";
			sceneFile << "***SCENE HEADER***\n";
			sceneFile << "name:" << name << "\t";
			sceneFile << "num_entities:" << entity_count << "\t";
			sceneFile << "phy_sleeping_enabled:" << boolSer(world->isSleepingEnabled()) << "\t";
			sceneFile << "phy_gravity:" << vec3Ser(world->getGravity()) << "\t";
			sceneFile << "phy_velocity_iterations:" << world->getNbIterationsVelocitySolver() << "\t";
			sceneFile << "phy_position_iterations:" << world->getNbIterationsPositionSolver() << "\n";
			sceneFile << "***START ENTITIES***\n";

			unsigned int i = 0;
			while (i < entity_count)
			{
				//sceneFile << "model:" << entities->models[i].model_path;
				sceneFile << "I'm a model!";
				sceneFile << "\n";
				i += 1;
			}

			// close file handlers
			sceneFile.close();
		}
		catch (std::ifstream::failure& e)
		{
			std::cout << "ERROR::SCENE_LOADER::FILE_NOT_WRITTEN" << std::endl;
		}

		return true;
	}

	//SceneHeader loadScene(string path, string name)
	//{
	//}

	string boolSer(bool val)
	{
		if (val)
		{
			return "1";
		}
		return "0";
	}
	string vec3Ser(Vector3 val)
	{
		string str = "";
		str += to_string(val.x);
		str += ",";
		str += to_string(val.y);
		str += ",";
		str += to_string(val.z);
		return str;
	}
};

struct SceneHeader
{
	string name;
	string path;
	unsigned int num_entities;
	bool phy_sleeping_enabled;
	Vector3 phy_gravity;
	unsigned int phy_velocity_iterations;
	unsigned int phy_position_iterations;
	struct SceneEntity* entities;
};

struct SceneEntity
{
	string model_path;
	glm::vec3 world_position;
	glm::vec3 world_rotation;
	Vector3 rigidbody_position;
	Vector3 rigidbody_rotation;
	unsigned int rigidbody_type;
	unsigned int collider_shape_type;
	// There will be logic in our file loader class that will tell us how many initializers our collider needs.
	float* collider_initializers;
	float collider_bounciness;
	float collider_friction;
	float collider_rolling_resist;
	float mass_density;
	bool collider_sleep;
	unsigned short collider_category_bits;
	unsigned short collider_collide_mask_bits;
	unsigned int id;
	unsigned int shaderIndex;
	string name;
};
