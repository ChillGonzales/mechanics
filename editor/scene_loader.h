#pragma once
#include <iostream>
#include "..\mechanics\model.h"
#include <reactphysics3d/reactphysics3d.h>
#include "scene_manager.h"

using namespace std;
using namespace reactphysics3d;

string boolSer(bool val);
string vec3Ser(Vector3 val);
string transformSer(Transform val);
string vec3Ser(Vector3 val);
string bodyTypeSer(BodyType val);
string collShapeNameSer(CollisionShapeName val);
string collShapeInitSer(CollisionShape* val);

struct SceneLoader
{
	bool writeSceneToDisk(string pathWithNameAndExt, string name, struct RenderingState* renders, struct PhysicsState* phy_entities, PhysicsWorld* world)
	{
		std::ofstream sceneFile;
		sceneFile.exceptions(std::ofstream::failbit | std::ofstream::badbit);
		try
		{
			// open file
			sceneFile.open(pathWithNameAndExt);
			if (!sceneFile.is_open())
			{
				cout << "Could not open scene file at location: '" << pathWithNameAndExt << "'.";
				return false;
			}

			sceneFile << "***AUTOGENERATED FILE CREATED BY scene_loader.h***\n";
			sceneFile << "***SCENE HEADER***\n";
			sceneFile << "name:" << name << "\t";
			sceneFile << "phy_sleeping_enabled:" << boolSer(world->isSleepingEnabled()) << "\t";
			sceneFile << "phy_gravity:" << vec3Ser(world->getGravity()) << "\t";
			sceneFile << "phy_velocity_iterations:" << world->getNbIterationsVelocitySolver() << "\t";
			sceneFile << "phy_position_iterations:" << world->getNbIterationsPositionSolver() << "\n";

			sceneFile << "***START RENDER DATA***\n";
			for (unsigned int i = 0; i < renders->length; i++)
			{
				sceneFile << "transform:" << transformSer(renders->transforms[i]) << "\t";
				sceneFile << "model_path:" << renders->models[i].model_path;
				sceneFile << "\n";
			}

			sceneFile << "***START PHYSICS DATA***\n";
			for (unsigned int i = 0; i < phy_entities->length; i++)
			{
				/**
				*
	unsigned int collider_shape_type;
	// There will be logic in our file loader class that will tell us how many initializers our collider needs.
	float* collider_initializers;
	float collider_bounciness;
	float collider_friction;
	float collider_rolling_resist;
	float mass_density;
	bool collider_sleep;
	unsigned short collider_category_bits;
	unsigned short collider_collide_mask_bits;
	unsigned int id;
	unsigned int shaderIndex;

				* */
				sceneFile << "rbody_transform:" << transformSer(phy_entities->bodies[i]->getTransform()) << "\t";
				sceneFile << "rbody_type:" << bodyTypeSer(phy_entities->bodies[i]->getType()) << "\t";
				sceneFile << "collider_shape_type:" << collShapeNameSer(phy_entities->colliders[i]->getCollisionShape()->getName()) << "\t";
				sceneFile << "collider_shape_values:" << collShapeInitSer(phy_entities->colliders[i]->getCollisionShape()) << "\t";
				sceneFile << "\n";
			}

			// close file handlers
			sceneFile.close();
		}
		catch (std::ifstream::failure& e)
		{
			std::cout << "ERROR::SCENE_LOADER::FILE_NOT_WRITTEN" << std::endl;
		}

		return true;
	}

	//SceneHeader loadScene(string path, string name)
	//{
	//}

};

string boolSer(bool val)
{
	if (val)
	{
		return "1";
	}
	return "0";
}
string vec3Ser(Vector3 val)
{
	string str = "";
	str += to_string(val.x);
	str += ",";
	str += to_string(val.y);
	str += ",";
	str += to_string(val.z);
	return str;
}
string transformSer(Transform val)
{
	auto pos = val.getPosition();
	auto quat = val.getOrientation();
	string str = "";
	str += vec3Ser(pos);
	str += ",";
	str += to_string(quat.x);
	str += ",";
	str += to_string(quat.y);
	str += ",";
	str += to_string(quat.z);
	str += ",";
	str += to_string(quat.w);
	return str;
}

string bodyTypeSer(BodyType val)
{
	switch (val)
	{
	case BodyType::STATIC: return "0";
	case BodyType::KINEMATIC: return "1";
	case BodyType::DYNAMIC: return "2";
	}
	return "0";
}

string collShapeNameSer(CollisionShapeName val)
{
	switch (val)
	{
	case CollisionShapeName::TRIANGLE: return "triangle";
	case CollisionShapeName::SPHERE: return "sphere";
	case CollisionShapeName::CAPSULE: return "capsule";
	case CollisionShapeName::BOX: return "box";
	}
	return "box";
}

string collShapeInitSer(CollisionShape* val)
{
	string str = "";
	switch (val->getName())
	{
	case CollisionShapeName::TRIANGLE:
		auto tri = dynamic_cast<TriangleShape*>(val);
		// TODO: Implement
		return str;
	case CollisionShapeName::BOX:
		auto box = dynamic_cast<BoxShape*>(val);
		return vec3Ser(box->getHalfExtents());
	case CollisionShapeName::CAPSULE:
		auto cap = dynamic_cast<CapsuleShape*>(val);
		str += to_string(cap->getHeight());
		str += ",";
		str += to_string(cap->getRadius());
	}
	return str;
}
string vec3Ser(Vector3 val)
{
	string str = "";
	str += to_string(val.x);
	str += ",";
	str += to_string(val.y);
	str += ",";
	str += to_string(val.z);
	return str;
}

struct SceneHeader
{
	string name;
	string path;
	unsigned int num_entities;
	bool phy_sleeping_enabled;
	Vector3 phy_gravity;
	unsigned int phy_velocity_iterations;
	unsigned int phy_position_iterations;
	struct SceneEntity* entities;
};

struct SceneEntity
{
	string model_path;
	glm::vec3 world_position;
	glm::vec3 world_rotation;
	Vector3 rigidbody_position;
	Vector3 rigidbody_rotation;
	unsigned int rigidbody_type;
	unsigned int collider_shape_type;
	// There will be logic in our file loader class that will tell us how many initializers our collider needs.
	float* collider_initializers;
	float collider_bounciness;
	float collider_friction;
	float collider_rolling_resist;
	float mass_density;
	bool collider_sleep;
	unsigned short collider_category_bits;
	unsigned short collider_collide_mask_bits;
	unsigned int id;
	unsigned int shaderIndex;
	string name;
};
