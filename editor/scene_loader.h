#pragma once
#include <iostream>
#include "..\mechanics\model.h"
#include <reactphysics3d/reactphysics3d.h>
#include "scene_manager.h"

using namespace std;
using namespace reactphysics3d;

string boolSer(bool val);
bool boolDeSer(string val);
string transformSer(Transform val);
Transform transformDeSer(string val);
string vec3Ser(Vector3 val);
Vector3 vec3DeSer(string val);
string bodyTypeSer(BodyType val);
BodyType bodyTypeDeSer(string val);
string collShapeNameSer(CollisionShapeName val);
CollisionShapeName collShapeNameDeSer(string val);
string collShapeInitSer(CollisionShape* val);
CollisionShape* collShapeInitDeSer(CollisionShapeName name, PhysicsCommon* common, string val);
vector<string> split(const string str, string delimiter);
vector<string> line_split(const string line);

struct SceneLoader
{
	bool writeSceneToDisk(string pathWithNameAndExt,
		string name,
		struct RenderingState* renders,
		struct PhysicsState* phy_entities,
		PhysicsWorld* world)
	{
		std::ofstream sceneFile;
		sceneFile.exceptions(std::ofstream::failbit | std::ofstream::badbit);
		try
		{
			// open file
			sceneFile.open(pathWithNameAndExt);
			if (!sceneFile.is_open())
			{
				cout << "Could not open scene file at location: '" << pathWithNameAndExt << "'.";
				return false;
			}

			sceneFile << "***AUTOGENERATED FILE CREATED BY scene_loader.h***\n";
			sceneFile << "***SCENE HEADER***\n";
			sceneFile << "name:" << name << "\t";
			sceneFile << "phy_sleeping_enabled:" << boolSer(world->isSleepingEnabled()) << "\t";
			sceneFile << "phy_gravity:" << vec3Ser(world->getGravity()) << "\t";
			sceneFile << "phy_velocity_iterations:" << world->getNbIterationsVelocitySolver() << "\t";
			sceneFile << "phy_position_iterations:" << world->getNbIterationsPositionSolver() << "\t";
			sceneFile << "render_obj_count:" << renders->length << "\t";
			sceneFile << "phy_obj_count:" << phy_entities->length << "\t";
			sceneFile << "\n";

			sceneFile << "***START RENDER DATA***\n";
			for (unsigned int i = 0; i < renders->length; i++)
			{
				sceneFile << "name:" << renders->names[i] << "\t";
				sceneFile << "transform:" << transformSer(renders->transforms[i]) << "\t";
				sceneFile << "model_path:" << renders->models[i].model_path << "\t";
				sceneFile << "shader_index:" << to_string(renders->shader_indices[i]);
				sceneFile << "\n";
			}

			sceneFile << "***START PHYSICS DATA***\n";
			for (unsigned int i = 0; i < phy_entities->length; i++)
			{
				sceneFile << "phy_obj_name:" << phy_entities->names[i] << "\t";
				sceneFile << "rbody_transform:" << transformSer(phy_entities->bodies[i]->getTransform()) << "\t";
				sceneFile << "rbody_type:" << bodyTypeSer(phy_entities->bodies[i]->getType()) << "\t";
				sceneFile << "rbody_sleep_enabled:" << phy_entities->bodies[i]->isAllowedToSleep() << "\t";
				sceneFile << "collider_shape_type:" << collShapeNameSer(phy_entities->colliders[i]->getCollisionShape()->getName()) << "\t";
				sceneFile << "collider_shape_values:" << collShapeInitSer(phy_entities->colliders[i]->getCollisionShape()) << "\t";
				sceneFile << "collider_mat_bounciness:" << to_string(phy_entities->colliders[i]->getMaterial().getBounciness()) << "\t";
				sceneFile << "collider_mat_friction:" << to_string(phy_entities->colliders[i]->getMaterial().getFrictionCoefficient()) << "\t";
				sceneFile << "collider_mat_rolling_resist:" << to_string(phy_entities->colliders[i]->getMaterial().getRollingResistance()) << "\t";
				sceneFile << "collider_mat_mass_density:" << to_string(phy_entities->colliders[i]->getMaterial().getMassDensity()) << "\t";
				sceneFile << "collider_category_bits:" << to_string(phy_entities->colliders[i]->getCollisionCategoryBits()) << "\t";
				sceneFile << "collider_collide_mask_bits:" << to_string(phy_entities->colliders[i]->getCollideWithMaskBits());
				sceneFile << "\n";
			}

			// close file handlers
			sceneFile.close();
		}
		catch (std::ifstream::failure& e)
		{
			std::cout << "ERROR::SCENE_LOADER::FILE_NOT_WRITTEN" << std::endl;
			return false;
		}

		return true;
	}

	struct SceneHeader* loadScene(string pathWithNameAndExt,
		string name,
		PhysicsWorld* world,
		PhysicsCommon* common)
	{
		std::ifstream sceneFile;
		SceneHeader* header = new SceneHeader;
		header->path = pathWithNameAndExt;
		sceneFile.open(pathWithNameAndExt);
		if (!sceneFile.is_open())
		{
			cout << "Could not open file at location '" << pathWithNameAndExt << "'. Failed." << endl;
			return nullptr;
		}

		string line;
		unsigned int sectionIx = 0;
		string sections[3] = { "header", "render", "physics" };
		unsigned int obj_counter = 0;
		while (getline(sceneFile, line))
		{
			// Comment token
			if (line.substr(0, 3) == "***") continue;

			if (sectionIx == 0)
			{
				auto segs = line_split(line);
				header->name = segs[0];
				header->phy_sleeping_enabled = boolDeSer(segs[1]);
				header->phy_gravity = vec3DeSer(segs[2]);
				header->phy_velocity_iterations = stoi(segs[3]);
				header->phy_position_iterations = stoi(segs[4]);
				header->render_obj_count = stoi(segs[5]);
				header->phy_obj_count = stoi(segs[6]);
				header->renders = new RenderingState(header->render_obj_count);
				header->physics = new PhysicsState(header->phy_obj_count);
				sectionIx += 1;
				continue;
			}
			if (sectionIx == 1)
			{
				auto segs = line_split(line);
				header->renders->names[obj_counter] = segs[0];
				header->renders->transforms[obj_counter] = transformDeSer(segs[1]);
				header->renders->models[obj_counter] = Model(segs[2]);
				header->renders->shader_indices[obj_counter] = stoi(segs[3]);

				obj_counter += 1;
				if (obj_counter == header->render_obj_count)
				{
					sectionIx += 1;
					obj_counter = 0;
					continue;
				}
			}
			if (sectionIx == 2)
			{
				auto segs = line_split(line);
				header->physics->names[obj_counter] = segs[0];
				auto rb_trans = transformDeSer(segs[1]);
				auto rb_type = bodyTypeDeSer(segs[2]);
				auto sleep_enabled = boolDeSer(segs[3]);
				RigidBody* body = world->createRigidBody(rb_trans);
				body->setType(rb_type);
				body->setIsAllowedToSleep(sleep_enabled);
				header->physics->bodies[obj_counter] = body;

				auto coll_shape_name = collShapeNameDeSer(segs[4]);
				auto coll_shape = collShapeInitDeSer(coll_shape_name, common, segs[5]);
				auto bounce = stof(segs[6]);
				auto friction = stof(segs[7]);
				auto rolling = stof(segs[8]);
				auto density = stof(segs[9]);
				auto category_bits = (unsigned short)stoul(segs[10]);
				auto category_mask = (unsigned short)stoul(segs[11]);
				Collider* coll;
				coll = body->addCollider(coll_shape, Transform::identity()); // Hardcoding this offset transform for now
				coll->getMaterial().setBounciness(bounce);
				coll->getMaterial().setFrictionCoefficient(friction);
				coll->getMaterial().setRollingResistance(rolling);
				coll->getMaterial().setMassDensity(density);
				coll->setCollisionCategoryBits(category_bits);
				coll->setCollideWithMaskBits(category_mask);
				header->physics->colliders[obj_counter] = coll;

				obj_counter += 1;
				if (obj_counter == header->phy_obj_count)
				{
					sectionIx += 1;
					obj_counter = 0;
					continue;
				}
			}
		}
		sceneFile.close();
		return header;
	}
};

vector<string> split(const string str, string delimiter)
{
	vector<string> output;
	string s = str;
	size_t pos = 0;
	std::string token;
	while ((pos = s.find(delimiter)) != std::string::npos)
	{
		token = s.substr(0, pos);
		output.push_back(token);
		s.erase(0, pos + delimiter.length());
	}
	if (s != "")
		output.push_back(s);
	return output;
}

vector<string> line_split(const string line)
{
	// each item in the line is in a key:value format. 
	// We're disposing of the keys for now as we're just hardcoding order/presence.
	// That might change in the future.
	vector<string> tokens;
	auto segs = split(line, "\t");
	for (int i = 0; i < segs.size(); i++)
	{
		auto t = split(segs[i], ":");
		tokens.push_back(t[1]);
	}
	return tokens;
}

string boolSer(bool val)
{
	if (val)
	{
		return "1";
	}
	return "0";
}
bool boolDeSer(string val)
{
	return val == "1";
}
string vec3Ser(Vector3 val)
{
	string str = "";
	str += to_string(val.x);
	str += ",";
	str += to_string(val.y);
	str += ",";
	str += to_string(val.z);
	return str;
}
Vector3 vec3DeSer(string val)
{
	auto segs = split(val, ",");
	return Vector3(stof(segs[0]), stof(segs[1]), stof(segs[2]));
}
string transformSer(Transform val)
{
	auto pos = val.getPosition();
	auto quat = val.getOrientation();
	string str = "";
	str += vec3Ser(pos);
	str += ",";
	str += to_string(quat.x);
	str += ",";
	str += to_string(quat.y);
	str += ",";
	str += to_string(quat.z);
	str += ",";
	str += to_string(quat.w);
	return str;
}

Transform transformDeSer(string val)
{
	auto segs = split(val, ",");
	auto vec = Vector3(stof(segs[0]), stof(segs[1]), stof(segs[2]));
	auto quat = Quaternion(stof(segs[3]), stof(segs[4]), stof(segs[5]), stof(segs[6]));
	return Transform(vec, quat);
}

string bodyTypeSer(BodyType val)
{
	switch (val)
	{
	case BodyType::STATIC: return "0";
	case BodyType::KINEMATIC: return "1";
	case BodyType::DYNAMIC: return "2";
	}
	return "0";
}

BodyType bodyTypeDeSer(string val)
{
	if (val == "0") return BodyType::STATIC;
	if (val == "1") return BodyType::KINEMATIC;
	if (val == "2") return BodyType::DYNAMIC;

	cout << "Unhandled rigid body type" << endl;
	assert(false);
}

string collShapeNameSer(CollisionShapeName val)
{
	switch (val)
	{
	case CollisionShapeName::TRIANGLE: return "triangle";
	case CollisionShapeName::SPHERE: return "sphere";
	case CollisionShapeName::CAPSULE: return "capsule";
	case CollisionShapeName::BOX: return "box";
	}
	return "box";
}

CollisionShapeName collShapeNameDeSer(string val)
{
	if (val == "triangle") return CollisionShapeName::TRIANGLE;
	if (val == "capsule") return CollisionShapeName::CAPSULE;
	if (val == "sphere") return CollisionShapeName::SPHERE;
	if (val == "box") return CollisionShapeName::BOX;

	cout << "Failed to deser collision shape name." << endl;
	assert(false);
}

string collShapeInitSer(CollisionShape* val)
{
	string str = "";
	switch (val->getName())
	{
	case CollisionShapeName::TRIANGLE:
	{
		auto tri = dynamic_cast<TriangleShape*>(val);
		// TODO: Implement
		break;
	}
	case CollisionShapeName::BOX:
	{
		auto box = dynamic_cast<BoxShape*>(val);
		str = vec3Ser(box->getHalfExtents());
		break;
	}
	case CollisionShapeName::CAPSULE:
	{
		auto cap = dynamic_cast<CapsuleShape*>(val);
		str += to_string(cap->getHeight());
		str += ",";
		str += to_string(cap->getRadius());
		break;
	}
	case CollisionShapeName::SPHERE:
	{
		auto sp = dynamic_cast<SphereShape*>(val);
		str += to_string(sp->getRadius());
		break;
	}
	}
	return str;
}

CollisionShape* collShapeInitDeSer(CollisionShapeName name, PhysicsCommon* common, string val)
{
	switch (name)
	{
	case CollisionShapeName::TRIANGLE:
	{
		// TODO: Implement
		return nullptr;
	}
	case CollisionShapeName::BOX:
	{
		auto extents = vec3DeSer(val);
		return common->createBoxShape(extents);
	}
	case CollisionShapeName::CAPSULE:
	{
		auto segs = split(val, ",");
		assert(segs.size() == 2);

		return common->createCapsuleShape(stof(segs[1]), stof(segs[0]));
	}
	case CollisionShapeName::SPHERE:
	{
		return common->createSphereShape(stof(val));
	}
	}
}
